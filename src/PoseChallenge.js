import React, { useRef, useEffect, useState, useCallback } from 'react';
import { Camera } from '@mediapipe/camera_utils';
import { Pose } from '@mediapipe/pose';

// MediaPipe„ÅÆÊèèÁîª„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„ÅØ„ÄÅindex.html„Åß„Ç∞„É≠„Éº„Éê„É´„Å´„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„ÇãÂâçÊèê
// window.drawConnectors, window.drawLandmarks „ÅåÂà©Áî®ÂèØËÉΩ„Å®‰ªÆÂÆö

// challenges.js „Åã„Çâ„ÅÆ„Ç§„É≥„Éù„Éº„Éà („Éë„Çπ„ÅØÁí∞Â¢É„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ)
import { CHALLENGES, TARGET_ANGLES, TOLERANCE, LANDMARKS as LANDMARK_INDICES } from '../data/challenges'; 

// =========================================================================
// üéØ „Éò„É´„Éë„ÉºÈñ¢Êï∞: „Éù„Éº„Ç∫Ê§úÂá∫„Å®„Çπ„Ç≥„Ç¢Ë®àÁÆó („Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂ§ñÈÉ®)
// =========================================================================

/**
 * 3„Å§„ÅÆ„É©„É≥„Éâ„Éû„Éº„ÇØ„Åã„ÇâËßíÂ∫¶„ÇíË®àÁÆó
 */
const calculateAngle = (A, M, B) => {
    const vectorMA_x = A.x - M.x;
    const vectorMA_y = A.y - M.y;
    const vectorMB_x = B.x - M.x;
    const vectorMB_y = B.y - M.y;

    const dotProduct = (vectorMA_x * vectorMB_x) + (vectorMA_y * vectorMB_y);
    const magnitudeMA = Math.sqrt(Math.pow(vectorMA_x, 2) + Math.pow(vectorMA_y, 2));
    const magnitudeMB = Math.sqrt(Math.pow(vectorMB_x, 2) + Math.pow(vectorMB_y, 2));
    
    let angleDeg = 0;
    if (magnitudeMA !== 0 && magnitudeMB !== 0) {
        let cosTheta = dotProduct / (magnitudeMA * magnitudeMB);
        cosTheta = Math.max(-1, Math.min(1, cosTheta));
        let angleRad = Math.acos(cosTheta);
        angleDeg = angleRad * (180 / Math.PI);
    }
    return angleDeg;
};

/**
 * Ëµ∑Âãï„Éà„É™„Ç¨„ÉºÁî®„ÅÆ„Éù„Éº„Ç∫„ÅåÂèñ„Çâ„Çå„Å¶„ÅÑ„Çã„ÅãÂà§ÂÆö„Åô„Çã (‰∏°ËÖïÂûÇÁõ¥‰∏ä„Åí)
 */
const isStartPoseAchieved = (landmarks) => {
    const L = LANDMARK_INDICES;
    const target = TARGET_ANGLES;
    const tolerance = TOLERANCE.START_TOLERANCE;

    if (!landmarks) return false;

    const requiredLandmarks = [L.LEFT_SHOULDER, L.LEFT_ELBOW, L.LEFT_WRIST, L.LEFT_HIP,
                               L.RIGHT_SHOULDER, L.RIGHT_ELBOW, L.RIGHT_WRIST, L.RIGHT_HIP];
    for (const index of requiredLandmarks) {
        if (!landmarks[index] || landmarks[index].visibility < 0.7) {
            return false;
        }
    }

    const leftElbowAngle = calculateAngle(landmarks[L.LEFT_SHOULDER], landmarks[L.LEFT_ELBOW], landmarks[L.LEFT_WRIST]);
    const leftShoulderAngle = calculateAngle(landmarks[L.LEFT_HIP], landmarks[L.LEFT_SHOULDER], landmarks[L.LEFT_ELBOW]);
    const isLeftArmReady = (
        Math.abs(leftElbowAngle - target.ELBOW) <= tolerance &&
        Math.abs(leftShoulderAngle - target.SHOULDER) <= tolerance
    );

    const rightElbowAngle = calculateAngle(landmarks[L.RIGHT_SHOULDER], landmarks[L.RIGHT_ELBOW], landmarks[L.RIGHT_WRIST]);
    const rightShoulderAngle = calculateAngle(landmarks[L.RIGHT_HIP], landmarks[L.RIGHT_SHOULDER], landmarks[L.RIGHT_ELBOW]);
    const isRightArmReady = (
        Math.abs(rightElbowAngle - target.ELBOW) <= tolerance &&
        Math.abs(rightShoulderAngle - target.SHOULDER) <= tolerance
    );

    return isLeftArmReady && isRightArmReady;
};


// =========================================================================
// üöÄ React„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
// =========================================================================

const PoseChallenge = () => {
    // DOMÂèÇÁÖß
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const poseRef = useRef(null); // Pose„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰øùÊåÅ

    // Áä∂ÊÖãÁÆ°ÁêÜ
    const [currentChallengeIndex, setCurrentChallengeIndex] = useState(0);
    const [challengeState, setChallengeState] = useState({
        isPoseFixed: false,
        isChallengeStarted: false,
        isInPreparationPhase: false,
        finalPoseLandmarks: null,
        currentScore: '--',
        guideMessage: '„Ç´„É°„É©Ëµ∑Âãï‰∏≠...',
        timerDisplay: null,
        challenges: JSON.parse(JSON.stringify(CHALLENGES)), // „ÉÅ„É£„É¨„É≥„Ç∏„É™„Çπ„Éà„ÇíÁä∂ÊÖã„Å®„Åó„Å¶„Ç≥„Éî„Éº
        scoreColor: '#4CAF50',
    });
    
    // „Çπ„Ç≥„Ç¢Ë®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ (useCallback„Åß„É°„É¢Âåñ)
    const calculateMatchScore = useCallback((currentLandmarks) => {
        const challenge = challengeState.challenges[currentChallengeIndex];
        const L = LANDMARK_INDICES;
        const target = TARGET_ANGLES;
        const tolerance = TOLERANCE;
        let totalScore = 0;
        let jointCount = 0;

        if (!challenge) return 0;

        // --- 1. ARM„ÉÅ„É£„É¨„É≥„Ç∏ (‰∏äÂçäË∫´) „ÅÆË©ï‰æ° ---
        if (challenge.targetType === 'ARM') {
            const side = challenge.evalJoints[0].includes('L') ? 'LEFT' : 'RIGHT';
            
            const S = L[`${side}_SHOULDER`];
            const E = L[`${side}_ELBOW`];
            const W = L[`${side}_WRIST`];
            const H = L[`${side}_HIP`];

            if (currentLandmarks[S].visibility < 0.7 || currentLandmarks[E].visibility < 0.7 || 
                currentLandmarks[W].visibility < 0.7 || currentLandmarks[H].visibility < 0.7) {
                return 0;
            }

            const currentElbowAngle = calculateAngle(currentLandmarks[S], currentLandmarks[E], currentLandmarks[W]);
            const currentShoulderAngle = calculateAngle(currentLandmarks[H], currentLandmarks[S], currentLandmarks[E]);

            const diffElbow = Math.abs(currentElbowAngle - target.ELBOW);
            const diffShoulder = Math.abs(currentShoulderAngle - target.SHOULDER);
            
            const scoreElbow = 100 * (1 - (diffElbow / tolerance.ELBOW));
            const scoreShoulder = 100 * (1 - (diffShoulder / tolerance.SHOULDER));

            totalScore += Math.max(0, scoreElbow);
            totalScore += Math.max(0, scoreShoulder);
            jointCount += 2;
        } 
        
        // --- 2. LEG_BALANCE„ÉÅ„É£„É¨„É≥„Ç∏ (ÂÖ®Ë∫´) „ÅÆË©ï‰æ° ---
        else if (challenge.targetType === 'LEG_BALANCE') {
            // Âè≥Ë∂≥Ëª∏„ÅÆÁâáË∂≥Á´ã„Å°„ÇíÊÉ≥ÂÆö
            const R_K = L.RIGHT_KNEE;
            const R_A = L.RIGHT_ANKLE;
            const R_H = L.RIGHT_HIP;
            const L_H = L.LEFT_HIP;

            // ÂèØË¶ñÊÄß„ÉÅ„Çß„ÉÉ„ÇØ: Ëª∏Ë∂≥„ÅÆËÜù„ÉªË∂≥È¶ñ„Å®‰∏°ËÖ∞
            if (currentLandmarks[R_K].visibility < 0.7 || currentLandmarks[R_A].visibility < 0.7 || 
                currentLandmarks[R_H].visibility < 0.7 || currentLandmarks[L_H].visibility < 0.7) {
                return 0;
            }

            // 2-1. Ëª∏Ë∂≥„ÅÆËÜù„ÅÆ‰º∏„Å≥ (ËÖ∞-ËÜù-Ë∂≥È¶ñ)
            const currentKneeAngle = calculateAngle(currentLandmarks[R_H], currentLandmarks[R_K], currentLandmarks[R_A]);
            const diffKnee = Math.abs(currentKneeAngle - target.KNEE_STRAIGHT);
            const scoreKnee = 100 * (1 - (diffKnee / tolerance.KNEE));
            
            totalScore += Math.max(0, scoreKnee);
            jointCount += 1;

            // 2-2. ‰ΩìÂππ„ÅÆÂûÇÁõ¥ÂÆâÂÆöÊÄß (Ëª∏Ë∂≥„ÅÆ„Éí„ÉÉ„Éó„Å®ËÜù„ÇíÁµê„Å∂Á∑ö„ÅÆÂÇæ„Åç)
            const angleRad = Math.atan2(currentLandmarks[R_H].x - currentLandmarks[R_K].x, currentLandmarks[R_H].y - currentLandmarks[R_K].y);
            const verticalAngle = Math.abs(angleRad * (180 / Math.PI)); 
            const tiltDiff = Math.min(verticalAngle, Math.abs(180 - verticalAngle)); 
            
            const scoreTilt = 100 * (1 - (tiltDiff / tolerance.TILT));
            
            totalScore += Math.max(0, scoreTilt);
            jointCount += 1;
            
            // 2-3. ËÖ∞„ÅÆÊ∞¥Âπ≥„Éê„É©„É≥„Çπ„ÉÅ„Çß„ÉÉ„ÇØÔºàÂ∑¶Âè≥„ÅÆËÖ∞„ÅÆYÂ∫ßÊ®ô„ÅÆÂ∑Æ„ÅåÂ∞ë„Å™„ÅÑ„Åª„Å©ËâØ„ÅÑÔºâ
            const canvasElement = canvasRef.current;
            const hipDeltaY = Math.abs(currentLandmarks[R_H].y - currentLandmarks[L_H].y) * (canvasElement ? canvasElement.height : 480); 
            
            // 20„Éî„ÇØ„Çª„É´‰ª•ÂÜÖ„ÅÆ„Ç∫„É¨„Çí100ÁÇπ„Å®„Åó„Å¶Ë©ï‰æ°
            const hipBalanceScore = Math.max(0, 100 * (1 - (hipDeltaY / 20))); 
            
            totalScore += hipBalanceScore;
            jointCount += 1;
        }

        if (jointCount === 0) return 0;
        
        return parseFloat((totalScore / jointCount).toFixed(1)); 
    }, [challengeState.challenges, currentChallengeIndex]);


    // --- „ÉÅ„É£„É¨„É≥„Ç∏ÁÆ°ÁêÜÈñ¢Êï∞ ---

    const showFinalResults = useCallback(() => {
        let totalScore = 0;
        let scoreList = "";
        
        challengeState.challenges.forEach((c) => {
            totalScore += c.score;
            scoreList += `${c.name}: ${c.score.toFixed(1)}%\n`;
        });
        
        const averageScore = totalScore / challengeState.challenges.length;
        
        let message, scoreColor;
        if (averageScore > 90) {
            scoreColor = '#4CAF50';
            message = `üéâ **ÂÖ®„ÉÅ„É£„É¨„É≥„Ç∏ÂÆå‰∫ÜÔºÅ** Âπ≥Âùá„Çπ„Ç≥„Ç¢: ${averageScore.toFixed(1)}%<br>Á¥†Êô¥„Çâ„Åó„ÅÑ„Éë„Éº„Éï„Çß„ÇØ„ÉàÈÅîÊàê„Åß„ÅôÔºÅ`;
        } else {
            scoreColor = '#FFC107';
            message = `**ÂÖ®„ÉÅ„É£„É¨„É≥„Ç∏ÂÆå‰∫ÜÔºÅ** Âπ≥Âùá„Çπ„Ç≥„Ç¢: ${averageScore.toFixed(1)}%<br>ÁµêÊûú„Çí„Ç≥„É≥„ÇΩ„Éº„É´„ÅßÁ¢∫Ë™ç„Åó„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÉÅ„É£„É¨„É≥„Ç∏„Åó„Åæ„Åó„Çá„ÅÜÔºÅ`;
        }

        setChallengeState(prev => ({
            ...prev,
            currentScore: `${averageScore.toFixed(1)} % (Âπ≥Âùá)`,
            guideMessage: message,
            scoreColor: scoreColor
        }));

        console.log("--- FINAL CHALLENGE RESULTS ---");
        console.log(scoreList);
        console.log(`Average Score: ${averageScore.toFixed(1)}%`);
    }, [challengeState.challenges]);


    const resetChallenge = useCallback((nextStage = false) => {
        let newIndex = currentChallengeIndex;
        if (nextStage) {
            newIndex += 1;
        }

        if (newIndex < challengeState.challenges.length) {
            setChallengeState(prev => ({
                ...prev,
                isPoseFixed: false,
                finalPoseLandmarks: null,
                isChallengeStarted: false,
                isInPreparationPhase: false,
                currentScore: '--',
                guideMessage: `„ÉÅ„É£„É¨„É≥„Ç∏ÈñãÂßã„ÅÆ„Åü„ÇÅ„ÄÅ‰∏°Êâã„ÇíÂûÇÁõ¥„Å´‰∏ä„Åí„Å¶„Éù„Éº„Ç∫„ÇíÁ∂≠ÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
                timerDisplay: null,
                scoreColor: '#4CAF50',
            }));
            setCurrentChallengeIndex(newIndex);
        } else {
            showFinalResults();
        }
    }, [currentChallengeIndex, challengeState.challenges, showFinalResults]);


    const startChallengeTimer = useCallback(() => {
        if (challengeState.isChallengeStarted) return;
        
        setChallengeState(prev => ({ ...prev, isChallengeStarted: true }));

        const COUNTDOWN_SECONDS = 3;
        const HOLD_SECONDS = 5;
        // const TOTAL_DELAY_SECONDS = COUNTDOWN_SECONDS + HOLD_SECONDS; // „É≠„Éº„Ç´„É´„Åß„ÅÆÂèÇÁÖß„ÅØ‰∏çË¶Å

        let startTime = Date.now();

        const timerId = setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            
            if (elapsed < COUNTDOWN_SECONDS) {
                const remaining = COUNTDOWN_SECONDS - elapsed;
                setChallengeState(prev => ({ 
                    ...prev, 
                    timerDisplay: remaining, 
                    guideMessage: `„Éù„Éº„Ç∫„ÇíÂèñ„ÇãÊ∫ñÂÇôÔºÅÊÆã„Çä ${remaining} ÁßíÔºÅ` 
                }));
            } else if (elapsed < (COUNTDOWN_SECONDS + HOLD_SECONDS)) {
                const holdTime = elapsed - COUNTDOWN_SECONDS;
                setChallengeState(prev => ({ 
                    ...prev, 
                    timerDisplay: 'GO!', 
                    guideMessage: `„Éù„Éº„Ç∫„ÇíÁ∂≠ÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅÊ∏¨ÂÆö‰∏≠... ${holdTime + 1} / ${HOLD_SECONDS} Áßí` 
                }));
            } else {
                clearInterval(timerId);
                setChallengeState(prev => ({ 
                    ...prev, 
                    isPoseFixed: true, 
                    timerDisplay: null,
                    guideMessage: '„Éù„Éº„Ç∫Á¢∫ÂÆöÔºÅÊúÄÁµÇ„Çπ„Ç≥„Ç¢„ÇíË®àÁÆó‰∏≠„Åß„Åô„ÄÇ'
                }));
            }
        }, 1000);

        return () => clearInterval(timerId);
    }, [challengeState.isChallengeStarted]);


    const startPreparationPhase = useCallback(() => {
        if (challengeState.isChallengeStarted || challengeState.isInPreparationPhase) return;
        
        const currentChallenge = challengeState.challenges[currentChallengeIndex];
        
        setChallengeState(prev => ({
            ...prev,
            isInPreparationPhase: true,
            guideMessage: `‚úÖ ${currentChallenge.message} „Éù„Éº„Ç∫„ÇíÁ¢∫Ë™çÔºÅ„Åù„ÅÆ„Åæ„Åæ„Åß„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ...`
        }));

        setTimeout(() => {
            setChallengeState(prev => ({ ...prev, isInPreparationPhase: false }));
            startChallengeTimer();
        }, 1500); // 1.5Áßí„ÅÆÊ∫ñÂÇôÊúüÈñì
    }, [challengeState, currentChallengeIndex, startChallengeTimer]);


    // --- MediaPipe ÁµêÊûúÂá¶ÁêÜ ---

    const onResults = useCallback((results) => {
        const canvasElement = canvasRef.current;
        if (!canvasElement) return;

        const canvasCtx = canvasElement.getContext('2d');

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.globalCompositeOperation = 'source_over';
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.poseLandmarks) {
            
            // 1. „ÉÅ„É£„É¨„É≥„Ç∏ÈñãÂßã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!challengeState.isChallengeStarted && !challengeState.isInPreparationPhase && currentChallengeIndex < challengeState.challenges.length && isStartPoseAchieved(results.poseLandmarks)) {
                startPreparationPhase();
            }

            // 2. „Éù„Éº„Ç∫Á¢∫ÂÆö„ÅÆÁû¨Èñì„ÄÅ„Éá„Éº„Çø„Çí‰øùÂ≠ò
            if (challengeState.isPoseFixed && !challengeState.finalPoseLandmarks) {
                const finalLandmarks = JSON.parse(JSON.stringify(results.poseLandmarks));
                const score = calculateMatchScore(finalLandmarks);
                
                // Áä∂ÊÖã„ÇíÊõ¥Êñ∞
                setChallengeState(prev => {
                    const updatedChallenges = [...prev.challenges];
                    updatedChallenges[currentChallengeIndex].score = score;
                    
                    let message, scoreColor;
                    if (score > 90) {
                        scoreColor = '#4CAF50'; 
                        message = `üåü ${prev.challenges[currentChallengeIndex].name} ÂÆå‰∫ÜÔºÅ„Éë„Éº„Éï„Çß„ÇØ„ÉàÈÅîÊàê„Åß„ÅôÔºÅ`;
                    } else if (score > 70) {
                        scoreColor = '#FFC107';
                        message = `${prev.challenges[currentChallengeIndex].name} ÂÆå‰∫ÜÔºÅ„ÇÇ„ÅÜÂ∞ë„Åó„ÅßÁõÆÊ®ôÈÅîÊàê„Åß„Åó„ÅüÔºÅ`;
                    } else {
                        scoreColor = '#F44336';
                        message = `${prev.challenges[currentChallengeIndex].name} ÂÆå‰∫Ü„ÄÇÊÉú„Åó„Åã„Å£„Åü„Åß„ÅôÔºÅ`;
                    }

                    return {
                        ...prev,
                        finalPoseLandmarks: finalLandmarks,
                        challenges: updatedChallenges,
                        currentScore: `${score.toFixed(1)} % (FINAL)`,
                        guideMessage: message,
                        scoreColor: scoreColor
                    };
                });

                // 1ÁßíÂæå„Å´Ê¨°„ÅÆ„ÉÅ„É£„É¨„É≥„Ç∏„Å∏ÁßªË°å„Åæ„Åü„ÅØÁµÇ‰∫Ü
                setTimeout(() => {
                    resetChallenge(true);
                }, 1000);
            }

            // 3. ÊèèÁîª„Å®„É™„Ç¢„É´„Çø„Ç§„É†„Çπ„Ç≥„Ç¢„ÅÆÊõ¥Êñ∞
            const drawingLandmarks = challengeState.finalPoseLandmarks || results.poseLandmarks;
            const isFixed = challengeState.isPoseFixed;

            const lineColor = isFixed ? '#FFD700' : '#00FF00'; 
            const dotColor = isFixed ? '#FFA500' : '#FF0000'; 
            
            if (window.drawConnectors && window.drawLandmarks) {
                window.drawConnectors(canvasCtx, drawingLandmarks, window.POSE_CONNECTIONS,
                                   { color: lineColor, lineWidth: 4 }); 
                window.drawLandmarks(canvasCtx, drawingLandmarks,
                                    { color: dotColor, lineWidth: 2, radius: 4 });
            }

            // „É™„Ç¢„É´„Çø„Ç§„É†„Çπ„Ç≥„Ç¢„ÅÆÊõ¥Êñ∞
            if (!challengeState.finalPoseLandmarks && challengeState.isChallengeStarted) {
                const score = calculateMatchScore(results.poseLandmarks);
                let scoreColor;
                if (score > 80) scoreColor = '#4CAF50';
                else if (score > 50) scoreColor = '#FFA500';
                else scoreColor = '#F44336';

                setChallengeState(prev => ({
                    ...prev,
                    currentScore: `${score.toFixed(1)} %`,
                    scoreColor: scoreColor
                }));
            }
        }
        
        canvasCtx.restore();
    }, [challengeState, currentChallengeIndex, calculateMatchScore, startPreparationPhase, resetChallenge]);


    // --- MediaPipe & „Ç´„É°„É©ÂàùÊúüÂåñ (useEffect) ---

    useEffect(() => {
        const videoElement = videoRef.current;
        
        // Pose„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„Å™„Åë„Çå„Å∞‰ΩúÊàê
        if (!poseRef.current) {
             poseRef.current = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
            });

            poseRef.current.setOptions({
                modelComplexity: 1, 
                smoothLandmarks: true
            });
            poseRef.current.onResults(onResults);
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                // isPoseFixed „Åå false „ÅÆÂ†¥Âêà„ÅÆ„ÅøÊ§úÂá∫„Éï„É¨„Éº„É†„ÇíÈÄÅ‰ø°
                if (!challengeState.isPoseFixed && poseRef.current) {
                    await poseRef.current.send({ image: videoElement });
                }
                // Âõ∫ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅonResults„ÅØuseEffectÂ§ñ„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„ÅßÊâãÂãï„ÅßÂëº„Å∞„Çå„Çã
            },
            width: 640,
            height: 480
        });

        camera.start()
            .then(() => {
                setChallengeState(prev => ({
                    ...prev,
                    guideMessage: `„Ç´„É°„É©Ëµ∑ÂãïÂÆå‰∫ÜÔºÅ„ÉÅ„É£„É¨„É≥„Ç∏ÈñãÂßã„ÅÆ„Åü„ÇÅ„ÄÅ‰∏°Êâã„ÇíÂûÇÁõ¥„Å´‰∏ä„Åí„Å¶„Éù„Éº„Ç∫„ÇíÁ∂≠ÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`
                }));
            })
            .catch(error => {
                setChallengeState(prev => ({
                    ...prev,
                    guideMessage: `„Ç®„É©„Éº: „Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ (${error.name})`
                }));
                console.error("Camera start failed:", error);
            });

        // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        return () => {
            // Camera„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åï„Çå„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
            // MediaPipe„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπËá™‰Ωì„ÅØ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åå„Ç¢„É≥„Éû„Ç¶„É≥„Éà„Åï„Çå„Çã„Åæ„Åß‰øùÊåÅ
        };
    }, [onResults, challengeState.isPoseFixed]); // challengeState.finalPoseLandmarks „ÅØ‰∏çË¶Å (onResults„Åå‰æùÂ≠ò„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ)


    // --- JSX „É¨„É≥„ÉÄ„É™„É≥„Ç∞ ---

    return (
        <div id="main-layout">
            <div id="video-container">
                {/* MediaPipe„ÅÆÂÜÖÈÉ®Âá¶ÁêÜ„Å´‰Ωø„ÅÜ„Éì„Éá„Ç™Ë¶ÅÁ¥† */}
                <video ref={videoRef} id="video" playsInline></video>
                {/* ÊèèÁîªÁµêÊûú„ÇíË°®Á§∫„Åô„Çã„Ç≠„É£„É≥„Éê„ÇπË¶ÅÁ¥† */}
                <canvas ref={canvasRef} id="canvas"></canvas>
            </div>

            <div id="result-box">
                <div 
                    id="timer-display" 
                    className={challengeState.timerDisplay !== null ? 'show-timer' : ''}
                >
                    {challengeState.timerDisplay}
                </div>
                
                <p>
                    ÁèæÂú®„ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞Â∫¶: 
                    <span 
                        id="match-score" 
                        style={{ color: challengeState.scoreColor || '#4CAF50' }}
                    >
                        {challengeState.currentScore}
                    </span>
                </p>
                {/* dangerouslySetInnerHTML„Çí‰ΩøÁî®„Åó„Å¶HTML„Çø„Ç∞„ÇíÂê´„ÇÄ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫ */}
                <div id="guide-message" dangerouslySetInnerHTML={{ __html: challengeState.guideMessage }}>
                </div>
            </div>
        </div>
    );
};

export default PoseChallenge;